The plan for refactoring

- Replace all of the separate optype classes and make one class of op
    - These store op, optional view, axis, and stride (and maybe the parents/children)?
- Make enums to represent all of the different types of operations (for each sub group)
- Carry these changes over to the Tensor class
- rewrite the lexer to break everything down into tokens (likely just ops, but have to think about this)
 - make dialects for specific languages?
    - I think scrap the lexer and parser concepts, the lexing is done by python/the user, the parsing and 
    - syntactic analysis is done by the pre-defined rules (add semantic analysis in later), so we just need to schedule and load everything
    - the same ideas as below hold, but just don't worry about the naming so much
- use these ops to drive the parser steps
    - I don't think I need to order these in the lexer, just pass back the tokens (update topological sort to include ops)
        - tensors can contain shape, view, data type, etc (do I need to even create tokens for these???)
    - can combine by close proximity tensors and create the operations objects (nodes) for future semantic analysis
        - don't need further information, just have to keep track of previous loads as points for combination into binary ops
        - unary ops (or movement) are directly descended from loads or any immediate parent op
    - this outputs a parse tree
    - then we can convert this into an ast (what is now called IR)
        - convert load IR to INDEX?
- merge everything in code and first pass into a compiler instance
- GOAL of the rewrite: make everything easier to follow/neater at the cost of a little speed